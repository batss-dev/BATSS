[{"path":"/articles/web_only/Ingredients.html","id":"n","dir":"Articles > Web_only","previous_headings":"","what":"n","title":"Ingredients","text":"object type: vector integers length order argument prob0. description: n provides number participants completed follow treatment arm look interest. includes control intervention arms, active dropped (inactive). sum(n) therefore corresponds total number participants completed follow--date trial.","code":""},{"path":"/articles/web_only/Ingredients.html","id":"m","dir":"Articles > Web_only","previous_headings":"","what":"m","title":"Ingredients","text":"object type: integer scalar. description: m corresponds number participants randomised different groups (including control) given look. therefore needed RAR group allocation functions .","code":""},{"path":"/articles/web_only/Ingredients.html","id":"n-1","dir":"Articles > Web_only","previous_headings":"","what":"N","title":"Ingredients","text":"object type: integer scalar. description: N corresponds maximum sample size trial specified argument N batss.glm.","code":""},{"path":"/articles/web_only/Ingredients.html","id":"posterior","dir":"Articles > Web_only","previous_headings":"","what":"posterior","title":"Ingredients","text":"Depending context - efficacy, futility RAR - posterior corresponds (possibly) different probabilities takes different lengths. object type: numerical scalar. description: context, posterior corresponds (posterior) probability target parameter greater smaller (depending argument 'alternative' [batss.glm]) ‘delta.eff’. object type: numerical scalar. description: context, posterior corresponds (posterior) probability target parameter greater smaller (depending argument 'alternative' [batss.glm]) ‘delta.fut’. object type: numerical vector length ‘number active target parameters’ given look. description: context, posterior corresponds vector (posterior) probabilities active target parameters greater smaller (depending argument 'alternative' [batss.glm]) ‘delta.RAR’.","code":""},{"path":"/articles/web_only/Ingredients.html","id":"active","dir":"Articles > Web_only","previous_headings":"","what":"active","title":"Ingredients","text":"object type: vector length order 'prob0'. description: active indicates different arms (including control group) active (TRUE) (FALSE) look interest.","code":""},{"path":"/articles/web_only/Ingredients.html","id":"ref","dir":"Articles > Web_only","previous_headings":"","what":"ref","title":"Ingredients","text":"object type: vector length order 'prob0'. description: ref indicates group reference one (TRUE). typically first one reference group typically dropped position 1 'prob0'.","code":""},{"path":"/articles/web_only/Ingredients.html","id":"prob","dir":"Articles > Web_only","previous_headings":"","what":"prob","title":"Ingredients","text":"object type: named numerical vector length ‘number active arms (including reference group)’. description: prob output -defined function provided ‘RAR’ used defining vector allocation ratios probabilities active arms (including reference group). Note , RAR = NULL, prob equals prob0 (appropriate subsetting arms dropped).","code":""},{"path":"/articles/web_only/Ingredients.html","id":"eff-target","dir":"Articles > Web_only","previous_headings":"","what":"eff.target","title":"Ingredients","text":"object type: vector length argument (.e., number target parameters) description: eff.target indicates efficacy reached target parameter stage interest .","code":""},{"path":"/articles/web_only/Ingredients.html","id":"fut-target","dir":"Articles > Web_only","previous_headings":"","what":"fut.target","title":"Ingredients","text":"object type: vector length argument (.e., number target parameters) description: fut.target indicates futility declared target parameter stage interest .","code":""},{"path":"/articles/web_only/Priors.html","id":"introduction","dir":"Articles > Web_only","previous_headings":"","what":"Introduction","title":"Prior distributions","text":"Laplace approximation provides analytical method estimate posterior distribution parameters complex models assuming posterior distributions can approximated Gaussian densities centered mode (maximum). calculation integrals related posteriors therefore greatly simplified, typically leading computational gain, especially complex models. R several implementations Laplace approximations Bayesian inference, TMB (Template Model Builder), LaplacesDemon mgcv packages, example. BATSS builds integrated nested Laplace approximation (INLA) R-INLA, implementation R. INLA methodology focuses models can expressed latent Gaussian Markov random fields (GMRF). Consider model \\[\\eta_i = g(\\mu_i) = \\alpha + \\sum_{j=1}^p \\beta_j z_{ij} + \\sum_{k=1}^q f_{k}(u_{ik}) + \\epsilon_i\\] \\(\\eta\\) linear predictor, \\(g(.)\\) link function, \\(\\beta\\) \\(p\\) coefficients linear effects covariates \\(z\\), \\(f_{k}(.)\\) \\(q\\) unknown functions covariates \\(u\\) \\(\\epsilon\\) unstructured terms. Latent Gaussian models subset Bayesian additive models assign Gaussian prior latent field \\(\\mathcal{X}=\\{\\alpha, \\beta, f(.)\\}\\) \\[\\mathcal{X}|\\theta \\sim N(0,\\mathcal{Q}^{-1}(\\theta))\\] \\(\\mathcal{Q}\\) denotes precision matrix \\(\\theta\\) vector hyperparameters. joint density latent field, hyperparameters data \\[ \\pi(\\mathcal{X},\\theta|y) \\propto \\pi(\\theta)\\pi(\\mathcal{X}|\\theta)\\prod_{=1}^{n}\\pi(y_i|(\\mathcal{X})_i,\\theta)\\] \\(\\eta=\\mathcal{X}\\). posterior mariginals can approximated. Refer Rue, Martino, Chopin (2009) Van Niekerk et al. (2023) details.","code":""},{"path":"/articles/web_only/Priors.html","id":"priors-for-fixed-effects","dir":"Articles > Web_only","previous_headings":"","what":"Priors for fixed effects","title":"Prior distributions","text":"Hence, priors fixed effects INLA normally distributed (default mean \\(\\mu=0\\) precision \\(\\tau=0.001\\), since \\(\\sigma^{2}=1/{\\tau}\\), \\(N(0,\\,1000)\\)). control.fixed argument inla() function allows users change \\(\\mu\\) \\(\\tau\\). batss.glm() function allows control elements inla() function passed embedded INLA routine via ... argument. inla() differentiates intercept, mean.intercept prec.intercept, fixed effects, mean prec, e.g. control.fixed = list(mean=1) assign prior mean \\(1\\) fixed effects intercept. Individual prior means precision can set named lists control.fixed argument, e.g. control.fixed = list(prec=list(=1,B=2,default=0.1)) set prior precision \\(1\\) fixed effect , \\(2\\) fixed effect B \\(0.1\\) fixed effects. Take note BATSS nomenclature fixed effects combination names right hand side model argument factor levels allocation function var argument (match names vector prob0) standard model.matrix() function - first level factor ignored naming purposes reference level, e.g.  following example shows batss.glm() call without changes default prior fixed effects:","code":"y <- rnorm(30) treatment <- factor(rep(c(\"A\",\"B\",\"C\"),10)) levels(treatment) ## [1] \"A\" \"B\" \"C\" model <- y ~ treatment mm <- model.matrix(model) colnames(mm) ## [1] \"(Intercept)\" \"treatmentB\"  \"treatmentC\" efficacy.fun = function(posterior,efficacy.bound){   posterior > efficacy.bound   } group.fun = function(m,prob){   prob = abs(prob)/sum(abs(prob))   m0.g = floor(prob*m)   m0   = sum(m0.g)   factor(rep(names(prob),m0.g+rmultinom(1,m-m0,prob)),          levels=names(prob))   }   #BATSS using INLA's default normal priors, N(0,1000) sim1 = batss.glm(             model             = y ~ trt,              var               = list(y   = rnorm,                                    trt = group.fun),           var.control       = list(y = list(sd = 2)),           beta              = c(1, 1, 2),           which             = c(2:3),           R                 = 10,           N                 = 200,           interim           = list(recruited=100),           prob0             = c(C=1/3, T1=1/3, T2=1/3),           eff.arm           = efficacy.fun,           eff.arm.control   = list(efficacy.bound = 0.975),           delta.eff         = c(NA,0),           fut.arm           = NULL,           computation       = \"parallel\",           H0                = FALSE,           mc.cores          = parallel::detectCores()-1)   t(apply(sim1$H1$estimate[,3,],1,summary))  #BATSS using normal priors with N(1,4) for the fixed effect of intervention T1 and  #the intercept and N(0,4) for intervention T2 and all other fixed effects. sim2 = batss.glm(             model             = y ~ trt,              var               = list(y   = rnorm,                                    trt = group.fun),           var.control       = list(y = list(sd = 2)),           beta              = c(1, 1, 2),           which             = c(2:3),           R                 = 10,           N                 = 200,           interim           = list(recruited=100),           prob0             = c(C=1/3, T1=1/3, T2=1/3),           eff.arm           = efficacy.fun,           eff.arm.control   = list(efficacy.bound = 0.975),           delta.eff         = c(NA,0),           fut.arm           = NULL,           computation       = \"parallel\",           H0                = FALSE,           mc.cores          = parallel::detectCores()-1,           control.fixed     = list(mean.intercept=1,                                    prec.intercept=0.25,                                    mean = list(trtT1 = 1, default = 0),                                     prec = 0.25)           )    t(apply(sim2$H1$estimate[,3,],1,summary))"},{"path":"/articles/web_only/Priors.html","id":"priors-for-hyperparameters","dir":"Articles > Web_only","previous_headings":"","what":"Priors for hyperparameters","title":"Prior distributions","text":"INLA hyperparameters default priors currently available BATSS Based INLA’s defaults, family, hyperparameter associated default prior used BATSS listed Table 1 (see Simpson et al. (2017) depth description complexity priors). Detailed information can viewed typing inla.models()$likelihood$[FAMILYNAME] including default parameters, e.g. normal distribution: case normal distribution default prior hyperparameter \\(\\theta=log(\\tau)\\) log-gamma distribution parameters \\(=1\\) \\(b=0.00005\\). change prior distribution parameters use control.family argument inla() function. Priors hyperparameters can either built-prior user-defined function. Available predefined priors INLA: change prior one predefined INLA priors simply use control.family argument inla() function. example, control.family = list(hyper = list(prec = list(prior = \"logtnormal\"))) change prior distribution precision truncated normal prior. (Note name depend hyperparameter, prec.) two options define priors predefined INLA: 1. Providing tabulated distribution via table: 2. providing function via expression: statement.","code":"INLA::inla.models()$likelihood$gaussian ## $doc ## [1] \"The Gaussian likelihoood\" ##  ## $hyper ## $hyper$theta1 ## $hyper$theta1$hyperid ## [1] 65001 ## attr(,\"inla.read.only\") ## [1] FALSE ##  ## $hyper$theta1$name ## [1] \"log precision\" ## attr(,\"inla.read.only\") ## [1] FALSE ##  ## $hyper$theta1$short.name ## [1] \"prec\" ## attr(,\"inla.read.only\") ## [1] FALSE ##  ## $hyper$theta1$output.name ## [1] \"Precision for the Gaussian observations\" ## attr(,\"inla.read.only\") ## [1] FALSE ##  ## $hyper$theta1$output.name.intern ## [1] \"Log precision for the Gaussian observations\" ## attr(,\"inla.read.only\") ## [1] FALSE ##  ## $hyper$theta1$initial ## [1] 4 ## attr(,\"inla.read.only\") ## [1] FALSE ##  ## $hyper$theta1$fixed ## [1] FALSE ## attr(,\"inla.read.only\") ## [1] FALSE ##  ## $hyper$theta1$prior ## [1] \"loggamma\" ## attr(,\"inla.read.only\") ## [1] FALSE ##  ## $hyper$theta1$param ## [1] 1e+00 5e-05 ## attr(,\"inla.read.only\") ## [1] FALSE ##  ## $hyper$theta1$to.theta ## function (x)  ## log(x) ## <bytecode: 0x132850940> ## <environment: 0x13284cda0> ## attr(,\"inla.read.only\") ## [1] TRUE ##  ## $hyper$theta1$from.theta ## function (x)  ## exp(x) ## <bytecode: 0x132850a58> ## <environment: 0x13284cda0> ## attr(,\"inla.read.only\") ## [1] TRUE ##  ##  ## $hyper$theta2 ## $hyper$theta2$hyperid ## [1] 65002 ## attr(,\"inla.read.only\") ## [1] FALSE ##  ## $hyper$theta2$name ## [1] \"log precision offset\" ## attr(,\"inla.read.only\") ## [1] FALSE ##  ## $hyper$theta2$short.name ## [1] \"precoffset\" ## attr(,\"inla.read.only\") ## [1] FALSE ##  ## $hyper$theta2$output.name ## [1] \"NOT IN USE\" ## attr(,\"inla.read.only\") ## [1] FALSE ##  ## $hyper$theta2$output.name.intern ## [1] \"NOT IN USE\" ## attr(,\"inla.read.only\") ## [1] FALSE ##  ## $hyper$theta2$initial ## [1] 72.08731 ## attr(,\"inla.read.only\") ## [1] FALSE ##  ## $hyper$theta2$fixed ## [1] TRUE ## attr(,\"inla.read.only\") ## [1] FALSE ##  ## $hyper$theta2$prior ## [1] \"none\" ## attr(,\"inla.read.only\") ## [1] TRUE ##  ## $hyper$theta2$param ## numeric(0) ## attr(,\"inla.read.only\") ## [1] FALSE ##  ## $hyper$theta2$to.theta ## function (x)  ## log(x) ## <bytecode: 0x132850940> ## <environment: 0x13284cda0> ## attr(,\"inla.read.only\") ## [1] TRUE ##  ## $hyper$theta2$from.theta ## function (x)  ## exp(x) ## <bytecode: 0x132850a58> ## <environment: 0x13284cda0> ## attr(,\"inla.read.only\") ## [1] TRUE ##  ##  ##  ## $survival ## [1] FALSE ##  ## $discrete ## [1] FALSE ##  ## $link ## [1] \"default\"   \"identity\"  \"logit\"     \"loga\"      \"cauchit\"   \"log\"       ## [7] \"logoffset\" ##  ## $pdf ## [1] \"gaussian\" #BATSS using normal priors with N(1,4) for the fixed effect of intervention T1 and  #the intercept and N(0,4) for intervention T2 and all other fixed effects and a  #log-gamma(0.5,0.01) prior for the log precision hyperparameter. sim3 = batss.glm(             model             = y ~ trt,              var               = list(y   = rnorm,                                    trt = group.fun),           var.control       = list(y = list(sd = 2)),           beta              = c(1, 1, 2),           which             = c(2:3),           R                 = 10,           N                 = 200,           interim           = list(recruited=100),           prob0             = c(C=1/3, T1=1/3, T2=1/3),           eff.arm           = efficacy.fun,           eff.arm.control   = list(efficacy.bound = 0.975),           delta.eff         = c(NA,0),           fut.arm           = NULL,           computation       = \"parallel\",           H0                = FALSE,           mc.cores          = parallel::detectCores()-1,           control.fixed     = list(mean.intercept=1,                                    prec.intercept=0.25,                                    mean = list(trtT1 = 1, default = 0),                                     prec = 0.25),           control.family    = list(hyper = list(prec = list(param = c(0.5,0.01))))           )    t(apply(sim3$H1$estimate[,3,],1,summary)) INLA::inla.list.models(\"prior\") ## Section [prior] ##      betacorrelation               Beta prior for the correlation           ##      dirichlet                     Dirichlet prior                          ##      expression:                   A generic prior defined using expressions ##      flat                          A constant prior                         ##      gamma                         Gamma prior                              ##      gaussian                      Gaussian prior                           ##      invalid                       Void prior                               ##      jeffreystdf                   Jeffreys prior for the doc               ##      laplace                       Laplace prior                            ##      linksnintercept               Skew-normal-link intercept-prior         ##      logflat                       A constant prior for log(theta)          ##      loggamma                      Log-Gamma prior                          ##      logiflat                      A constant prior for log(1/theta)        ##      logitbeta                     Logit prior for a probability            ##      logtgaussian                  Truncated Gaussian prior                 ##      logtnormal                    Truncated Normal prior                   ##      minuslogsqrtruncnormal        (obsolete)                               ##      mvnorm                        A multivariate Normal prior              ##      none                          No prior                                 ##      normal                        Normal prior                             ##      pc                            Generic PC prior                         ##      pc.alphaw                     PC prior for alpha in Weibull            ##      pc.ar                         PC prior for the AR(p) model             ##      pc.cor0                       PC prior correlation, basemodel cor=0    ##      pc.cor1                       PC prior correlation, basemodel cor=1    ##      pc.dof                        PC prior for log(dof-2)                  ##      pc.fgnh                       PC prior for the Hurst parameter in FGN  ##      pc.gamma                      PC prior for a Gamma parameter           ##      pc.gammacount                 PC prior for the GammaCount likelihood   ##      pc.gevtail                    PC prior for the tail in the GEV likelihood ##      pc.matern                     PC prior for the Matern SPDE             ##      pc.mgamma                     PC prior for a Gamma parameter           ##      pc.prec                       PC prior for log(precision)              ##      pc.range                      PC prior for the range in the Matern SPDE ##      pc.sn                         PC prior for the skew-normal             ##      pc.spde.GA                    (experimental)                           ##      pom                           #classes-dependent prior for the POM model ##      ref.ar                        Reference prior for the AR(p) model, p<=3 ##      rprior:                       A R-function defining the prior          ##      table:                        A generic tabulated prior                ##      wishart1d                     Wishart prior dim=1                      ##      wishart2d                     Wishart prior dim=2                      ##      wishart3d                     Wishart prior dim=3                      ##      wishart4d                     Wishart prior dim=4                      ##      wishart5d                     Wishart prior dim=5                      ##      wishartkd                     Wishart prior #BATSS with default normal priors for the fixed effects and a truncated normal prior #for the precision hyperparameter sim4 = batss.glm(             model             = y ~ trt,              var               = list(y   = rnorm,                                    trt = group.fun),           var.control       = list(y = list(sd = 2)),           beta              = c(1, 1, 2),           which             = c(2:3),           R                 = 10,           N                 = 200,           interim           = list(recruited=100),           prob0             = c(C=1/3, T1=1/3, T2=1/3),           eff.arm           = efficacy.fun,           eff.arm.control   = list(efficacy.bound = 0.975),           delta.eff         = c(NA,0),           fut.arm           = NULL,           computation       = \"parallel\",           H0                = FALSE,           mc.cores          = parallel::detectCores()-1,           control.family    = list(hyper = list(prec = list(prior = \"logtnormal\")))           )    t(apply(sim4$H1$estimate[,3,],1,summary)) #manually define the log-gamma prior # either as a 'table' loggamma.function <-  function(log_precision) {   a <- 0.05;   b <- 0.01;   precision <- exp(log_precision);   logdens <- log(b^a) - lgamma(a) + (a-1)*log_precision - b*precision;   log_jacobian <- log_precision;   return(logdens + log_jacobian) } lprec <- seq(-10, 10, len=10000) loggamma.tab <- paste(c(\"table:\", cbind(lprec, loggamma.function(lprec))),                        sep = \"\", collapse = \" \") loggamma.table <- list(prec = list(prior = loggamma.tab))  #BATSS using normal priors with N(1,4) for the fixed effect of intervention T1 and  #the intercept and N(0,4) for intervention T2 and all other fixed effects and a  #tabulated log-gamma(0.5,0.01) prior for the log precision hyperparameter. sim5 = batss.glm(             model             = y ~ trt,              var               = list(y   = rnorm,                                    trt = group.fun),           var.control       = list(y = list(sd = 2)),           beta              = c(1, 1, 2),           which             = c(2:3),           R                 = 10,           N                 = 200,           interim           = list(recruited=100),           prob0             = c(C=1/3, T1=1/3, T2=1/3),           eff.arm           = efficacy.fun,           eff.arm.control   = list(efficacy.bound = 0.975),           delta.eff         = c(NA,0),           fut.arm           = NULL,           computation       = \"parallel\",           H0                = FALSE,           mc.cores          = parallel::detectCores()-1,           control.fixed     = list(mean.intercept=1,                                    prec.intercept=0.25,                                    mean = list(trtT1 = 1, default = 0),                                     prec = 0.25),           control.family    = list(hyper = loggamma.table)           )    t(apply(sim5$H1$estimate[,3,],1,summary)) #or 'expression' loggamma = \"expression:               a = 0.5;               b = 0.01;               precision = exp(log_precision);               logdens = log(b^a) - lgamma(a) + (a-1)*log_precision - b*precision;               log_jacobian = log_precision;               return(logdens + log_jacobian);\" loggamma.expression = list(prec = list(prior = loggamma))  #BATSS using normal priors with N(1,4) for the fixed effect of intervention T1 and  #the intercept and N(0,4) for intervention T2 and all other fixed effects and a  #user-defined log-gamma(0.5,0.01) prior for the log precision hyperparameter. sim6 = batss.glm(             model             = y ~ trt,              var               = list(y   = rnorm,                                    trt = group.fun),           var.control       = list(y = list(sd = 2)),           beta              = c(1, 1, 2),           which             = c(2:3),           R                 = 10,           N                 = 200,           interim           = list(recruited=100),           prob0             = c(C=1/3, T1=1/3, T2=1/3),           eff.arm           = efficacy.fun,           eff.arm.control   = list(efficacy.bound = 0.975),           delta.eff         = c(NA,0),           fut.arm           = NULL,           computation       = \"parallel\",           H0                = FALSE,           mc.cores          = parallel::detectCores()-1,           control.fixed     = list(mean.intercept=1,                                    prec.intercept=0.25,                                    mean = list(trtT1 = 1, default = 0),                                     prec = 0.25),           control.family    = list(hyper = loggamma.expression)           )    t(apply(sim6$H1$estimate[,3,],1,summary))  #check if it matches the predefined loggamma prior t(apply(sim3$H1$estimate[,3,],1,summary))"},{"path":"/articles/web_only/Priors.html","id":"further-reading","dir":"Articles > Web_only","previous_headings":"","what":"Further reading","title":"Prior distributions","text":"details (including parametrisation distributions) examples use priors INLA (extension BATSS) can found INLA documentation inla.doc(\"[TOPIC]\") online (https://www.r-inla.org/).","code":""},{"path":[]},{"path":"/articles/web_only/binomial.html","id":"context","dir":"Articles > Web_only","previous_headings":"","what":"Context","title":"Binomial endpoint","text":"example motivated Personalised Immunotherapy Platform (PIP) trial (Lo et al. 2022), phase II randomised controlled trial currently development compare immunotherapy combinations advanced melanoma patients. study aims assess effectiveness different novel drug combinations compared control arm treatment-naive patients predicted unlikely respond standard first line immunotherapy treatments. primary outcome objective response rate (ORR, .e., probability observing one/success) according Response Evaluation Criteria Solid Tumors (RECIST) (partial complete response vs stable disease progressive disease) 6 months post randomisation.","code":""},{"path":"/articles/web_only/binomial.html","id":"design","dir":"Articles > Web_only","previous_headings":"","what":"Design","title":"Binomial endpoint","text":"chosen design following characteristics: treatment arms: case study 6 treatment arms: standard care (arm “”), five drug combinations (referred arms “B”, “C”, “D”, “E” “F”). alternative hypotheses: superiority trial interested demonstrating efficacy compared standard care arm intervention arms compared one another. interim analyses maximum sample size: begin interim analyses 60 participants completing follow-, perform interim analyses every 12 participants completing follow-thereafter. maximum sample size 216 participants total 14 looks planned. endpoint conditional distribution: binary endpoint assumed follow binomial distribution. \\(n_{kj}\\) corresponds sample size arm \\(k\\) (\\(k=0\\) denotes control arm) stage \\(j\\) \\(\\text{max}(n_{kj})\\) evaluated across intervention arms (.e. \\(k>0\\)), \\(K_j\\) number active arms (excluding control) look \\(j\\), \\(\\nu=0.1\\) tuning parameter. \\(\\beta_k\\) denotes \\(k\\)th target parameter (logit scale), \\(\\delta_{r} = 0\\) denotes (RAR-related) clinically meaningful treatment effect value, \\(n_{kj}\\), sample size arm \\(k\\) stage \\(j\\), \\(N\\), maximum sample size, \\(\\gamma=3\\) \\(\\eta=1.4\\), two tuning parameters. Refer Gotmaker et al. (2019) details efficacy stopping rule: Stopping arms efficacy permitted interim analyses main objective adaptations drop poorly performing arms. \\(\\delta_{\\epsilon} = 0\\) denotes (efficacy-related) clinically meaningful treatment effect value, \\(b_{\\epsilon}=0.045\\) tuning parameter. \\(\\delta_{f} = log(1.5)\\) denotes (futility-related) clinically meaningful treatment effect values assuming control ORR 40%, \\(b_{f} = 0.1\\) cut-value used declare futility. trial stopping rule: trial run futility decision reached intervention arm maximum sample size reached. Note , , tuning parameter values optimised lead suitable operating characteristics. following, define group allocation, RAR, futility efficacy functions corresponding design described ","code":""},{"path":"/articles/web_only/binomial.html","id":"rar","dir":"Articles > Web_only","previous_headings":"Design","what":"RAR","title":"Binomial endpoint","text":"need generate function defines allocation probabilities patients different active arms function posterior, posterior probabilities target parameter greater delta.RAR = 0, n N, respectively sample size per arm look interest max sample size define information fraction, ref, vector logicals indicating group reference one, active, vector logicals indicating groups active look interest, relevant tuning parameters (added RAR.control batss.glm), namely \\(\\gamma\\), \\(\\eta\\), \\(\\nu\\), respectively call gamma, eta nu Note corresponds function RAR.trippa available BATSS package.","code":"# function prob.trippa = function(posterior,n,N,ref,active,gamma,eta,nu){   g = sum(active)   h = gamma*(sum(n)/N)^eta   prob = rep(NA,g)   # reference/control arm allocation   prob[1] = (exp(max(n[!ref])-n[ref])^nu)/(g-1)   # targets/interventions (that haven't been dropped)   prob[2:g] = (posterior^h)/(sum(posterior^h))   unlist(prob)    } # test after at the first look with two set of posterior probabilities # 1/ c(.5,.5,.5,.5,.5) # 2/ c(.5,.5,.5,.5,.6) prob.trippa(c(.5,.5,.5,.5,.5),n=c(A=10,B=10,C=10,D=10,E=10,F=10),N=16,             ref = c(TRUE,rep(FALSE,5)), active = rep(TRUE,6),             gamma=3, eta=1.4, nu=0.1) prob.trippa(c(.5,.5,.5,.5,.6),n=c(A=10,B=10,C=10,D=10,E=10,F=10),N=16,             ref = c(TRUE,rep(FALSE,5)), active = rep(TRUE,6),             gamma=3, eta=1.4, nu=0.1)"},{"path":"/articles/web_only/binomial.html","id":"group-allocation","dir":"Articles > Web_only","previous_headings":"Design","what":"Group allocation","title":"Binomial endpoint","text":"need generate function randomises m participants next look according allocation ratios prob, m prob ingredients described Ingredients section prob output user-defined RAR function. treatalloc.fun first allocates largest possible number units different groups given exact target probabilities assigns randomly remaining units different groups according multinomial draws. Note corresponds function alloc.balanced available BATSS package.","code":"# function treatalloc.fun = function(m,prob){   prob = abs(prob)/sum(abs(prob))    m0.g = floor(prob*m)   m0   = sum(m0.g)   factor(rep(names(prob),m0.g+rmultinom(1,m-m0,prob)),          levels=names(prob)) } # test on m = 60 patients and equal allocation per group table(treatalloc.fun(m=60,prob=c(A=1,B=1,C=1,D=1,E=1,F=1)))"},{"path":"/articles/web_only/binomial.html","id":"efficacy-rule","dir":"Articles > Web_only","previous_headings":"Design","what":"Efficacy rule","title":"Binomial endpoint","text":"need generate function leads logical output used last look trial takes input ingredient posterior posterior probability target parameter greater delta.eff = 0, additional parameter \\(b_{\\epsilon}\\) name b.eff (needs added eff.arm.control batss.glm).","code":"# function efficacy.arm.fun = function(posterior,b.eff){   posterior > 1-b.eff  } # test for a parameter with a posterior = 0.999 efficacy.arm.fun(0.999, b.eff = 0.045) # test for a parameter with a posterior = 0.95 efficacy.arm.fun(0.95, b.eff = 0.045)"},{"path":"/articles/web_only/binomial.html","id":"arm-futility-stopping-rule","dir":"Articles > Web_only","previous_headings":"Design","what":"Arm futility stopping rule","title":"Binomial endpoint","text":"need generate function leads logical output takes input ingredient posterior posterior probability target parameter greater delta.fut = log(1.5), additional parameter \\(b_{f}\\) name b.fut (needs added fut.arm.control batss.glm) Note corresponds function fut.arm.simple available BATSS package.","code":"# function futility.arm.fun = function(posterior,b.fut){   posterior < b.fut } # test  futility.arm.fun(0.9, b.fut=0.1) futility.arm.fun(0.075, b.fut=0.1)"},{"path":"/articles/web_only/binomial.html","id":"trial-futility-stopping-rule","dir":"Articles > Web_only","previous_headings":"Design","what":"Trial futility stopping rule","title":"Binomial endpoint","text":"need generate function , based ingredient fut.target (indicating futility declared target parameter stage interest ) leads logical output equal TRUE target parameters declared futile FALSE otherwise. Note corresponds function fut.trial.available BATSS package behaviour default one function batss.glm fut.trial = NULL.","code":"# function futility.trial.fun = function(fut.target){   all(fut.target) }  # test  futility.trial.fun(c(B=TRUE,C=TRUE,D=TRUE,E=TRUE,F=TRUE)) futility.trial.fun(c(B=TRUE,C=TRUE,D=TRUE,E=TRUE,F=FALSE))"},{"path":"/articles/web_only/binomial.html","id":"monte-carlo-simulations","dir":"Articles > Web_only","previous_headings":"","what":"Monte Carlo Simulations","title":"Binomial endpoint","text":"consider two scenarios: Scenario 1: arm ORR 0.4 (global null), arms “”, “B” “C” ORR 0.4, arms “D” ORR 0.5, arms “E” “F” ORR 0.7.","code":""},{"path":"/articles/web_only/binomial.html","id":"scenario-1","dir":"Articles > Web_only","previous_headings":"Monte Carlo Simulations","what":"Scenario 1","title":"Binomial endpoint","text":"can note expit(logit(0.4)) = 0.4 reference group, logit(0.4) = -0.405 corresponds log odds ‘success’ control group, expit(logit(0.4+0)) = 0.4 groups (contrasts type treatment used factor treatment self-defined function treatalloc.fun), 0 corresponds log odds ratio value related groups “B” “F” (.e., effect), target parameters (corresponding shift ORR treatment arms “B” “F” compared “control” logit scale) position 2 6 fitted coefficients obtained using formula y~group, (equal) allocation probabilities start trial, names groups, eff.arm fut.arm set functions defined (.e., efficacy.arm.fun futility.arm.fun), delta.eff set NA 13 interim analyses 0 last look. ensures trial can’t stop early efficacy. aim achieved using strategies, like setting output function indicated eff.trial FALSE, fut.trial specified therefore equal NULL (default) leads behaviour wished case, values additional parameters efficacy.arm.fun futility.arm.fun (.e., b.eff b.fut) specified eff.arm.control fut.arm.control, delta.eff delta.fut respectively set 0 log(1.5). chose low number seeds/trials (R=25) save time.","code":"# number of trials R = 25  # logit function logit = function(p){log(p/(1 - p))}  # simulation scenario1 = batss.glm(      model           = y~group,   var             = list(y = rbinom,                          group = treatalloc.fun),   var.control     = list(y = list(size = 1)),    family          = \"binomial\",   link            = \"logit\",   beta            = c(logit(0.4), rep(0,5)),   which           = c(2:6),   R               = R,   alternative     = c(\"greater\"),   RAR             = prob.trippa,   RAR.control     = list(\"gamma\"=3, \"eta\"=1.4,\"nu\"=0.1),   delta.RAR       = 0,   prob0           = c(A=1,B=1,C=1,D=1,E=1,F=1),   N               = 216,    interim         = list(recruited=list(m0=60, m=12)),   eff.arm         = efficacy.arm.fun,   delta.eff       = c(rep(NA,13), 0),    eff.arm.control = list(b.eff = 0.045),   delta.fut       = log(1.5),    fut.arm         = futility.arm.fun,   fut.arm.control = list(b.fut = 0.1),   computation     = \"parallel\",   mc.cores        = 12,   H0              = FALSE,   extended        = 1)"},{"path":"/articles/web_only/binomial.html","id":"scenario-2","dir":"Articles > Web_only","previous_headings":"Monte Carlo Simulations","what":"Scenario 2","title":"Binomial endpoint","text":"except beta.","code":"# number of trials R = 25  # logit function logit = function(p){log(p/(1 - p))}  # simulation scenario1 = batss.glm(      model           = y~group,   var             = list(y = rbinom,                          group = treatalloc.fun),   var.control     = list(y = list(size = 1)),    family          = \"binomial\",   link            = \"logit\",   beta            = c(logit(0.4),                    # log odd of reference group                       0,0,                           # log odds ratio of groups B and C                              logit(0.5)-logit(0.4),         # log odds ratio of group D                       rep(logit(0.7)-logit(0.4),2)), # log odds ratio of groups E and F          which           = c(2:6),   R               = R,   alternative     = c(\"greater\"),   RAR             = prob.trippa,   RAR.control     = list(\"gamma\"=3, \"eta\"=1.4,\"nu\"=0.1),   delta.RAR       = 0,   prob0           = c(A=1,B=1,C=1,D=1,E=1,F=1),   N               = 216,    interim         = list(recruited=list(m0=60, m=12)),   eff.arm         = efficacy.arm.fun,   delta.eff       = c(rep(NA,13), 0),    eff.arm.control = list(b.eff = 0.045),   delta.fut       = log(1.5),    fut.arm         = futility.arm.fun,   fut.arm.control = list(b.fut = 0.1),   computation     = \"parallel\",   mc.cores        = 12,   H0              = FALSE,   extended        = 1)"},{"path":[]},{"path":"/articles/web_only/negbin.html","id":"context","dir":"Articles > Web_only","previous_headings":"","what":"Context","title":"Negative binomial endpoint","text":"case study inspired CHANGE-MS study (Curtin et al. 2016), multi-arm, phase II randomised controlled trial aimed study efficacy safety temelimab treatment relapsing-remitting multiple sclerosis (MS) determine whether temelimab slowed stopped progression MS. primary endpoint cumulative number new active lesions identified brain MRI scans performed 4 occasions (month) weeks 12-24 post-randomisation. data overdispersed (Curtin et al. 2016; Hartung et al. 2022) modelled using negative binomial GLM; use model .","code":""},{"path":"/articles/web_only/negbin.html","id":"design","dir":"Articles > Web_only","previous_headings":"","what":"Design","title":"Negative binomial endpoint","text":"chosen design following characteristics: treatment arms: case study 4 treatment arms: placebo (control), low, medium high doses temelimab (intervention arms referred arms “”, “B” “C”, respectively). alternative hypotheses: superiority trial interested demonstrating efficacy compared placebo arm intervention arms compared one another. interim analyses maximum sample size: begin interim analyses 100 participants completing follow-, perform interim analyses every 40 participants completing follow-thereafter. maximum sample size 260 participants, original study (Curtin et al. 2016). power: Similar original study, aim 90% power detect 60% reduction (RR=0.4) mean cumulative number lesions highest dose intervention arm (mean 4 (control) 1.6 lesions). endpoint conditional distribution: endpoint assumed follow negative binomial distribution nuisance parameter equal \\(\\phi = 0.5\\) considering parametrisation leading following variance: \\[\\text{Var}(Y) = \\mu + \\frac{\\mu^2}{\\phi}.\\] group allocation: consider equal allocation probabilities per group (response-adaptive randomisation). \\(\\beta_k\\) denotes \\(k\\)th target parameter, \\(\\delta_{\\epsilon} = 0\\) denotes (efficacy-related) clinically meaningful treatment effect value, \\(N\\) maximum sample size, \\(n_k\\) number participants completed follow arm \\(k=1,...,K\\) look \\(j\\) \\((\\sum_{k=1}^{K} n_k)/N\\) corresponds information fraction, \\(b_{\\epsilon} = 0.009\\) \\(p_{\\epsilon}=3\\) tuning parameters determine shape efficacy function (Gotmaker et al. 2019). \\(\\delta_{f} = log(0.8)\\) denotes (futility-related) clinically meaningful treatment effect values, \\(b_{f} = 0.2025\\) cut-value used declare futility. trial stopping rule: trial run efficacy futility decision reached intervention arm maximum sample size reached. Note , , parameter values \\(b_{f}\\), \\(b_{\\epsilon}\\) \\(p_{\\epsilon}\\) optimised via grid search lead suitable operating characteristics, parameters values \\(\\delta_{\\epsilon}\\) \\(\\delta_{f}\\) defined clinicians.","code":""},{"path":"/articles/web_only/negbin.html","id":"self-defined-r-functions","dir":"Articles > Web_only","previous_headings":"","what":"Self-defined R functions","title":"Negative binomial endpoint","text":"following, define group allocation, futility efficacy functions corresponding design described ","code":""},{"path":"/articles/web_only/negbin.html","id":"group-allocation","dir":"Articles > Web_only","previous_headings":"Self-defined R functions","what":"Group allocation","title":"Negative binomial endpoint","text":"need generate function randomises m participants next look according allocation ratios prob, m prob ingredients described Ingredients section. treatalloc.fun first allocates largest possible number units different groups given exact target probabilities assigns randomly remaining units different groups according multinomial draws. Note corresponds function alloc.balanced available BATSS package. RAR rule used, allocation probabilities used throughout trial batss.glm ones indicated prob0.","code":"# function treatalloc.fun = function(m,prob){   prob = abs(prob)/sum(abs(prob))    m0.g = floor(prob*m)   m0   = sum(m0.g)   factor(rep(names(prob),m0.g+rmultinom(1,m-m0,prob)),          levels=names(prob)) } # test on m = 40 patients and equal allocation per group table(treatalloc.fun(m=40,prob=c(control=.25,A=.25,B=.25,C=.25))) table(treatalloc.fun(m=40,prob=c(control=1,A=1,B=1,C=1)))"},{"path":"/articles/web_only/negbin.html","id":"arm-efficacy-stopping-rule","dir":"Articles > Web_only","previous_headings":"Self-defined R functions","what":"Arm efficacy stopping rule","title":"Negative binomial endpoint","text":"need generate function leads logical output takes input posterior posterior probability target parameter smaller delta.eff = 0, n N, respectively sample size per arm look interest max sample size define information fraction, \\(b_{\\epsilon}\\) name b.eff, \\(p_{\\epsilon}\\) name p.eff. Note correspond function eff.arm.infofract available BATSS package.","code":"# function efficacy.arm.fun = function(posterior,n,N,b.eff,p.eff){   posterior > (1-(b.eff*(sum(n)/N)^p.eff)) } # test at interim 1 for a parameter with a posterior = 0.999 efficacy.arm.fun(0.999, n=c(control=25,A=25,B=25,C=25),N=260,                  b.eff = 0.009,p.eff=3) # test at interim 1 for a parameter with a posterior = 0.9995 efficacy.arm.fun(0.9995, n=c(control=25,A=25,B=25,C=25),N=260,                  b.eff = 0.009,p.eff=3)"},{"path":"/articles/web_only/negbin.html","id":"trial-efficacy-stopping-rule","dir":"Articles > Web_only","previous_headings":"Self-defined R functions","what":"Trial efficacy stopping rule","title":"Negative binomial endpoint","text":"need generate function , based ingredient eff.target (indicating efficacy reached target parameter stage interest ) leads logical output equal TRUE target parameters reached efficacy FALSE otherwise. Note corresponds function eff.trial.available BATSS package behaviour default one function batss.glm eff.trial = NULL.","code":"# function efficacy.trial.fun = function(eff.target){   all(eff.target) }  # test  efficacy.trial.fun(c(A=TRUE,B=TRUE,C=TRUE)) efficacy.trial.fun(c(A=TRUE,B=TRUE,C=FALSE))"},{"path":"/articles/web_only/negbin.html","id":"arm-futility-stopping-rule","dir":"Articles > Web_only","previous_headings":"Self-defined R functions","what":"Arm futility stopping rule","title":"Negative binomial endpoint","text":"need generate function leads logical output takes input ingredients posterior posterior probability target parameter smaller delta.fut = log(0.8), additional parameters \\(b_{f}\\) name b.fut (needs added fut.arm.control batss.glm) Note corresponds function fut.arm.simple available BATSS package.","code":"# function futility.arm.fun = function(posterior,b.fut){   posterior < b.fut } # test  futility.arm.fun(0.9, b.fut=.2025) futility.arm.fun(0.1, b.fut=.2025)"},{"path":"/articles/web_only/negbin.html","id":"trial-futility-stopping-rule","dir":"Articles > Web_only","previous_headings":"Self-defined R functions","what":"Trial futility stopping rule","title":"Negative binomial endpoint","text":"need generate function , based ingredient fut.target (indicating futility declared target parameter stage interest ) leads logical output equal TRUE target parameters declared futile FALSE otherwise. Note corresponds function fut.trial.available BATSS package behaviour default one function batss.glm fut.trial = NULL.","code":"# function futility.trial.fun = function(fut.target){   all(fut.target) }  # test  futility.trial.fun(c(A=TRUE,B=TRUE,C=TRUE)) futility.trial.fun(c(A=TRUE,B=TRUE,C=FALSE))"},{"path":"/articles/web_only/negbin.html","id":"monte-carlo-simulations","dir":"Articles > Web_only","previous_headings":"","what":"Monte Carlo Simulations","title":"Negative binomial endpoint","text":"consider three scenarios: Scenario 1 = ‘global null’: arm cumulative mean number lesions equal 4, Scenario 2 = ‘one treatment works’: arm cumulative mean number lesions equal 4 except last one, “C”, shows 60% reduction cumulative mean number lesions compared groups (RR = 0.4), Scenario 3 = ‘better, best’: control arm cumulative mean number lesions equal 4 arms respectively lead 20%, 40% 60% reduction cumulative mean number lesions compared reference group (.e., RR = 0.8 “”, RR = 0.6 “B” RR = 0.4 “C”).","code":""},{"path":"/articles/web_only/negbin.html","id":"scenario-1","dir":"Articles > Web_only","previous_headings":"Monte Carlo Simulations","what":"Scenario 1","title":"Negative binomial endpoint","text":"can note log(4) control group, log(4)+log(1) = log(4) groups (contrasts type treatment used factor treatment self-defined function treatalloc.fun), target parameters (corresponding shift means treatment arms “”, “B” “C” compared “control” log scale) position 2, 3 4 fitted coefficients obtained using formula y~treatment, (equal) allocation probabilities throughout trial (RAR = NULL), names groups, eff.arm fut.arm set functions defined (.e., efficacy.arm.fun futility.arm.fun), eff.trial fut.trial specified therefore equal NULL (default) leads behaviour wished case, values additional parameters efficacy.arm.fun futility.arm.fun (.e., b.eff, p.eff b.fut) specified eff.arm.control fut.arm.control, delta.eff delta.fut respectively set 0 log(0.8). chose low number seeds/trials (R=25) save time.","code":"R = 25  scenario1 = batss.glm(      model           = y~treatment,   var             = list(y = rnbinom,                                    treatment = treatalloc.fun),   var.control     = list(y = list(size = 1/2)),    family          = \"nbinomial\",   link            = \"log\",   beta            = c(log(4),log(1),log(1),log(1)),   which           = c(2:4),   R               = R,   alternative     = c(\"less\"),   RAR             = NULL,   prob0           = c(control = .25, A = .25, B = .25, C = .25),   N               = 260,   interim         = list(recruited=c(100,140,180,220)),   eff.arm         = efficacy.arm.fun,   delta.eff       = 0,    eff.arm.control = list(\"b.eff\"=0.009, \"p.eff\"=3),   delta.fut       = log(0.8),    fut.arm         = futility.arm.fun,   fut.arm.control = list(\"b.fut\"=0.2025),   computation     = \"parallel\",   mc.cores        = 10,   H0              = TRUE,   extended        = 1)"},{"path":"/articles/web_only/negbin.html","id":"scenario-2","dir":"Articles > Web_only","previous_headings":"Monte Carlo Simulations","what":"Scenario 2","title":"Negative binomial endpoint","text":"except beta now leads mean exp(log(4)) = 4 control group, exp(log(4) + log(1)) = 4 (effect) groups “” “B”, exp(log(4) + log(0.4)) = 1.6 (target effect) group “C” corresponds RR 1.6/4 = 0.4.","code":"R = 25  scenario2 = batss.glm(      model           = y~treatment,   var             = list(y = rnbinom,                                    treatment = treatalloc.fun),   var.control     = list(y = list(size = 1/2)),    family          = \"nbinomial\",   link            = \"log\",   beta            = c(log(4),log(1),log(1),log(0.4)),   which           = c(2:4),   R               = R,   alternative     = c(\"less\"),   RAR             = NULL,   prob0           = c(control = .25, A = .25, B = .25, C = .25),   N               = 260,   interim         = list(recruited=c(100,140,180,220)),   eff.arm         = efficacy.arm.fun,   delta.eff       = 0,    eff.arm.control = list(\"b.eff\"=0.009, \"p.eff\"=3),   delta.fut       = log(0.8),    fut.arm         = futility.arm.fun,   fut.arm.control = list(\"b.fut\"=0.2025),   computation     = \"parallel\",   mc.cores        = 10,   H0              = TRUE,   extended        = 1)"},{"path":"/articles/web_only/negbin.html","id":"scenario-3","dir":"Articles > Web_only","previous_headings":"Monte Carlo Simulations","what":"Scenario 3","title":"Negative binomial endpoint","text":"except beta now leads mean exp(log(4)) = 4 control group, exp(log(4) + log(0.8)) = 3.2 (small effect) group “” corresponds RR 3.2/4 = 0.8, exp(log(4) + log(0.6)) = 2.4 (medium effect) group “B” corresponds RR 2.4/4 = 0.6, exp(log(4) + log(0.4)) = 1.6 (target effect) group “C” corresponds RR 1.6/4 = 0.4.","code":"R = 25  scenario3 = batss.glm(      model           = y~treatment,   var             = list(y = rnbinom,                                    treatment = treatalloc.fun),   var.control     = list(y = list(size = 1/2)),    family          = \"nbinomial\",   link            = \"log\",   beta            = c(log(4),log(0.8),log(0.6),log(0.4)),   which           = c(2:4),   R               = R,   alternative     = c(\"less\"),   RAR             = NULL,   prob0           = c(control = .25, A = .25, B = .25, C = .25),   N               = 260,   interim         = list(recruited=c(100,140,180,220)),   eff.arm         = efficacy.arm.fun,   delta.eff       = 0,    eff.arm.control = list(\"b.eff\"=0.009, \"p.eff\"=3),   delta.fut       = log(0.8),    fut.arm         = futility.arm.fun,   fut.arm.control = list(\"b.fut\"=0.2025),   computation     = \"parallel\",   mc.cores        = 10,   H0              = TRUE,   extended        = 1)"},{"path":[]},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Dominique-Laurent Couturier. Author, maintainer. Liz Ryan. Author. Rainer Puhr. Author. Thomas Jaki. Author. Stephane Heritier. Author.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Couturier D, Ryan L, Puhr R, Jaki T, Heritier S (2024). BATSS: Bayesian Adaptive Trial Simulator Software (BATSS) Generalised Linear Models. R package version 1.0.0, https://batss-dev.github.io/BATSS/.","code":"@Manual{,   title = {BATSS: Bayesian Adaptive Trial Simulator Software (BATSS) for Generalised Linear Models},   author = {Dominique-Laurent Couturier and Liz Ryan and Rainer Puhr and Thomas Jaki and Stephane Heritier},   year = {2024},   note = {R package version 1.0.0},   url = {https://batss-dev.github.io/BATSS/}, }"},{"path":"/index.html","id":"batss-r-package-","dir":"","previous_headings":"","what":"Package description","title":"Bayesian Adaptive Trial Simulator Software (BATSS) for Generalised Linear Models","text":"BATSS - Bayesian Adaptive Trials Simulator Software - provides flexible structure fast simulation Bayesian adaptive designs clinical trials. package can used define evaluate operating characteristics Bayesian adaptive designs various different types primary outcomes (e.g., follow normal, binary, Poisson negative binomial distribution) can incorporate common types adaptations: stopping treatments (entire trial) efficacy futility, Bayesian response adaptive randomisation - based user-defined adaptation rules. important features highly modular package include: parallel processing, customisability, use cluster computer PC/Mac, adjustment covariates. INLA needs installed prior installing BATSS. instructions, visit https://www.r-inla.org/download-install install BATSS package CRAN, run install development version BATSS package GitHub, run","code":"install.packages(\"BATSS\") install.packages(\"devtools\") devtools::install_github(\"batss-dev/BATSS\")"},{"path":"/reference/BATSS.html","id":null,"dir":"Reference","previous_headings":"","what":"BATSS — BATSS","title":"BATSS — BATSS","text":"BATSS","code":""},{"path":"/reference/RAR.optimal.html","id":null,"dir":"Reference","previous_headings":"","what":"'Optimal' control allocation — RAR.optimal","title":"'Optimal' control allocation — RAR.optimal","text":"technically response adaptive keeps allocation ratio control square root active intervention arms","code":""},{"path":"/reference/RAR.optimal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"'Optimal' control allocation — RAR.optimal","text":"","code":"RAR.optimal(active)"},{"path":"/reference/RAR.optimal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"'Optimal' control allocation — RAR.optimal","text":"active 'BATSS' ingredient 'active' corresponding logical vector length order 'prob0' (.e., number arms initially included study including reference group))  indicating arm active look interest.","code":""},{"path":"/reference/RAR.optimal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"'Optimal' control allocation — RAR.optimal","text":"RAR.optimal returns vector probabilities length active.","code":""},{"path":"/reference/RAR.trippa.html","id":null,"dir":"Reference","previous_headings":"","what":"RAR of Trippa et al. (2012) — RAR.trippa","title":"RAR of Trippa et al. (2012) — RAR.trippa","text":"define group allocation probabilities based response adaptive randomisation rule Trippa et al. (2012)","code":""},{"path":"/reference/RAR.trippa.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"RAR of Trippa et al. (2012) — RAR.trippa","text":"","code":"RAR.trippa(posterior, n, N, ref, active, gamma, eta, nu)"},{"path":"/reference/RAR.trippa.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"RAR of Trippa et al. (2012) — RAR.trippa","text":"posterior 'BATSS' ingredient 'posterior' corresponding, context, (posterior) probability active target parameters greater smaller (depending argument 'alternative' batss.glm) 'delta.RAR'. n 'BATSS' ingredient 'n' corresponding vector number recruited participants per arm including control group look interest. N 'BATSS' ingredient '`N' corresponding maximum (planned) sample size. ref 'BATSS' ingredient 'ref' corresponding logical vector length order 'prob0' (.e., number arms initially included study including reference group)) indicating group reference one. active 'BATSS' ingredient 'active' corresponding logical vector length order 'prob0' (.e., number arms initially included study including reference group))  indicating arm active look interest. gamma scaling factor (defined RAR.arm.control). eta scaling factor (defined RAR.arm.control). nu scaling factor (defined RAR.arm.control).","code":""},{"path":"/reference/RAR.trippa.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"RAR of Trippa et al. (2012) — RAR.trippa","text":"RAR.trippa returns vector probabilities length active.","code":""},{"path":"/reference/alloc.balanced.html","id":null,"dir":"Reference","previous_headings":"","what":"Balanced allocation function — alloc.balanced","title":"Balanced allocation function — alloc.balanced","text":"alloc.balanced first allocates largest possible number units different groups given exact target probabilities assigns randomly remaining units different groups according multinomial draws. method leads observed allocation probabilities matching target ones m*prob integer group observed allocation probabilities (average) closer target ones compared alloc.simple.","code":""},{"path":"/reference/alloc.balanced.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Balanced allocation function — alloc.balanced","text":"","code":"alloc.balanced(m, prob)"},{"path":"/reference/alloc.balanced.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Balanced allocation function — alloc.balanced","text":"m 'BATSS' ingredient 'm', scalar corresponding number participants allocated. prob 'BATSS' ingredient 'prob', named vector allocation ratios probabilities.","code":""},{"path":"/reference/alloc.balanced.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Balanced allocation function — alloc.balanced","text":"alloc.balanced returns object class factor length 'm' levels matching names vector 'prob'.","code":""},{"path":[]},{"path":"/reference/alloc.balanced.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Balanced allocation function — alloc.balanced","text":"","code":"alloc.balanced(100, prob = c(A=.4,B=.6)) #>   [1] A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A #>  [38] A A A B B B B B B B B B B B B B B B B B B B B B B B B B B B B B B B B B B #>  [75] B B B B B B B B B B B B B B B B B B B B B B B B B B #> Levels: A B table(alloc.balanced(100, prob = c(A=.4,B=.6))) #>  #>  A  B  #> 40 60  table(alloc.balanced(100, prob = c(A=.4,B=.6))) #>  #>  A  B  #> 40 60"},{"path":"/reference/alloc.simple.html","id":null,"dir":"Reference","previous_headings":"","what":"Simple allocation function — alloc.simple","title":"Simple allocation function — alloc.simple","text":"alloc.simple independently randomises unit group (.e., flips coin unit) observed allocation probabilities may far target ones. strategy often considered poor choice.","code":""},{"path":"/reference/alloc.simple.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simple allocation function — alloc.simple","text":"","code":"alloc.simple(m, prob)"},{"path":"/reference/alloc.simple.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simple allocation function — alloc.simple","text":"m 'BATSS' ingredient 'm', scalar corresponding number participants allocated. prob 'BATSS' ingredient 'prob', named vector allocation ratios probabilities.","code":""},{"path":"/reference/alloc.simple.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simple allocation function — alloc.simple","text":"alloc.simple returns object class factor length 'm' levels matching names vector 'prob'.","code":""},{"path":[]},{"path":"/reference/alloc.simple.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simple allocation function — alloc.simple","text":"","code":"alloc.simple(100, prob = c(A=.4,B=.6)) #>   [1] B A A B B B B B A A A B B B B B B B B A B A A B A A B B A A B B B A B B A #>  [38] A B B A B A A B A A A A B B B B B B A B A B B A B B B B B A B B B B B B B #>  [75] B B B B A B B A B B B A B B A B A B B A A B B A B B #> Levels: A B table(alloc.simple(100, prob = c(A=.4,B=.6))) #>  #>  A  B  #> 50 50  table(alloc.simple(100, prob = c(A=.4,B=.6))) #>  #>  A  B  #> 46 54"},{"path":"/reference/batss.combine.html","id":null,"dir":"Reference","previous_headings":"","what":"Combines outputs generated by batss.glm — batss.combine","title":"Combines outputs generated by batss.glm — batss.combine","text":"Combines different evaluations batss.glm considering trial design different sets seeds. function useful evaluation Monte Carlo samples generated different seeds split sets computed different nodes/cpus. output function class 'batss' meaning usual generic functions (print, summary, plot) can used.","code":""},{"path":"/reference/batss.combine.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combines outputs generated by batss.glm — batss.combine","text":"","code":"batss.combine(paths, force = FALSE)"},{"path":"/reference/batss.combine.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combines outputs generated by batss.glm — batss.combine","text":"paths Vector indicating paths rdata files containing outputs function batss.glm considering trial design different set seeds. requires argument 'extended' function batss.glm > 0. force logical default force=FALSE. Among checks, batss.glm controls calls Monte Carlo trials combined identical stops (Note check bullet proof: check, example, able note two sets Monte Carlo trials used eff.arm function named way considered optional parameters blind fact correspond two different functions). force=TRUE forces batss.glm ignore check. useful calls differ due batss objects combined generated using different versions batss.glm.","code":""},{"path":"/reference/batss.combine.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Combines outputs generated by batss.glm — batss.combine","text":"object class 'batss'. Refer section 'Value' batss.glm details object structure.","code":""},{"path":[]},{"path":"/reference/batss.glm.html","id":null,"dir":"Reference","previous_headings":"","what":"Bayesian adaptive trial simulations for generalised linear models — batss.glm","title":"Bayesian adaptive trial simulations for generalised linear models — batss.glm","text":"Simulation Bayesian adaptive trials GLM endpoint using Integrated Nested Laplace Approximation (INLA).","code":""},{"path":"/reference/batss.glm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bayesian adaptive trial simulations for generalised linear models — batss.glm","text":"","code":"batss.glm(   model,   var,   var.control = NULL,   family = \"gaussian\",   link = \"identity\",   beta,   which,   alternative = \"greater\",   R = 10000,   N,   interim,   prob0,   delta.eff = 0,   delta.fut = delta.eff,   delta.RAR = 0,   eff.arm,   eff.arm.control = NULL,   eff.trial = NULL,   eff.trial.control = NULL,   fut.arm,   fut.arm.control = NULL,   fut.trial = NULL,   fut.trial.control = NULL,   RAR = NULL,   RAR.control = NULL,   H0 = TRUE,   computation = \"parallel\",   mc.cores = getOption(\"mc.cores\", 3L),   extended = 0,   ... )"},{"path":"/reference/batss.glm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bayesian adaptive trial simulations for generalised linear models — batss.glm","text":"model object class 'formula' indicating symbolic description model fitted (lm glm functions). var list. entry corresponds variable described 'model' indicates name function allowing generate variates (like rnorm rexp, example). list names match variable names unded 'model' first element correspond model outcome. grouping variable corresponding target parameters class 'factor' levels corresponding names indicated argument prob0 (see ). var.control optional list control parameters functions indicated 'var'. names list items need correspond names used 'var'. element another list names elements corresponding parameter names functions specified 'var'. family character string indicating name conditional distribution described package INLA (check inla.list.models). Default set 'gaussian'. link character string describing link function used model relate outcome set predictors: 'identity', 'log', 'logit', 'probit', 'robit', 'cauchit', 'loglog' 'cloglog' currently available options. Default set 'identity'. beta numerical vector parameter values linear predictor. length match number column X matrix induced formula indicated 'model' (check model.matrix). numerical vector indicating position target beta parameters. alternative vector strings providing one-sided direction alternative hypothesis corresponding target parameter indicated '' (order). Possibilities 'greater' (default) 'less'. vector length 1, direction used target parameter tests. R vector natural numbers used seeds (check set.seed) different Monte Carlo trials (vector length thus correspond number Monte Carlo trials). R scalar, seeds 1 R used, R corresponds number Monte Carlo trials. N scalar indicating maximum sample size. interim list parameters related interim analyses. Currently, 'recruited' available.  consists vector integers indicating number completed observations look, last excluded, increasing order. prob0 named vector initial allocation probabilities. Names need correspond levels grouping variable. RAR = NULL, probabilities/ratios used throughout (fixed allocation probabilities). delta.eff vector (length equal number looks (.e., number interims + 1)) clinically meaningful treatment effect values (linear predictor scale) used define efficacy-related posterior probabilities target parameter look. scalar provided, value used look. default delta.eff = 0. delta.fut vector (length equal number looks (.e., number interims + 1)) clinically meaningful treatment effect values (linear predictor scale) used define futility-related posterior probabilities target parameter look. scalar provided, value used look. default delta.fut = delta.eff. delta.RAR vector (length equal number looks (.e., number interims + 1)) clinically meaningful treatment effect values (linear predictor scale) used define RAR-related posterior probabilities target parameter look. scalar provided, value used interim analysis. default delta.RAR = 0. Note , vector provided, last value ignored randomisation made last look. eff.arm function defining efficacy achieved given look given information available stage given target parameter. output function must logical (length 1). Arguments function typically consider 'BATSS' ingredients. Check eff.arm.simple eff.arm.infofract examples. eff.arm.control optional list parameters function indicated 'eff.arm'. eff.trial function defining trial can stopped efficacy given output function indicated 'eff.arm'. output function must logical length one. Arguments function typically consider 'BATSS' ingredient eff.target. Check eff.trial.eff.trial.examples. eff.trial = NULL (default), trial stops efficacy target parameters found effective (like eff.trial.). eff.trial.control optional list parameters function indicated 'eff.trial'. fut.arm function defining futility achieved given look given information available stage target parameter. output function must logical (length 1). Arguments function typically consider 'BATSS' ingredients. Check fut.arm.simple see example function. fut.arm.control optional list parameters function indicated 'fut.arm'. fut.trial function defining trial can stopped futility given output function indicated 'fut.arm'. output function must logical length one. Arguments function typically consider 'BATSS' ingredient fut.target. Check fut.trial.example function. fut.trial = NULL (default), trial stops futility target parameters found futile (like fut.trial.). fut.trial.control optional list parameters function indicated 'fut.trial'. RAR function defining response-adaptive randomisation probabilities group - reference group included - group names ordering used 'prob0'. Arguments function typically consider 'BATSS' ingredients. Check RAR.trippa RAR.optimal examples. RAR = NULL (default), probabilities/ratios indicated prob0 used throughout (fixed allocation probabilities). RAR.control optional list control parameters function provided 'RAR'. H0 logical indicating whether simulation also consider case target parameters set 0 check probability rejecting hypothesis target parameter value equal 0 individually (pairwise type error) globally (family-wise error rate). Default set H0=TRUE. computation character string indicating computation performed. Possibilities 'parallel' 'sequential' default computation=\"parallel\" meaning computation split mc.cores. mc.cores integer indicating number CPUs used computation=\"parallel\" (Default 3 global 'mc.cores' global option available via getOption). extended integer indicating type results returned. 0 (default) provides summary statistics, 1 adds results Monte Carlo trial 2 additionally returns Monte Carlo dataset. batss.combine requires extended > 0 function needs merge results different sets seeds. ... Additional arguments control fitting inla.","code":""},{"path":"/reference/batss.glm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bayesian adaptive trial simulations for generalised linear models — batss.glm","text":"function batss.glm returns S3 object class 'batss' available print/summary/plot functions beta - data frame providing information related beta parameter vector, like parameter names values, example. look - data frame providing information related looks, like sample size given interim (m) cumulative sample size given interim (n), example. par - list providing different information, like used seeds (seed) groups (group), example. H1 - list providing trial results alternative, like estimates per target parameter corresponding arm stopped (estimate), efficacy futility probabilites per target parameter overall (target, efficacy futility), sample size per group trial (sample), probabilities associated combination efficacy futility per group (scenario), detailed results per trial (trial), example. H0 - list providing trial results global null hypothesis (structure H1). call - matched call. type - type 'BATSS' analysis ('glm' currently available).","code":""},{"path":[]},{"path":"/reference/batss.glm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bayesian adaptive trial simulations for generalised linear models — batss.glm","text":"","code":"# \\donttest{ # Example:  # * Gaussian conditional distribution with sigma = 5 # * 3 groups with group means 'C' = 1 (ref), 'T1' = 2, 'T2' = 3, #     where higher means correspond to better outcomes  # * 5 interim analyses occurring when n = 100, 120, 140, 160, and 180 # * fixed and equal allocation probabilities per arm (i.e., no RAR) # * max sample size = 200  # * efficacy stop per arm when the prob of the corresponding parameter  #     being greater than 0 is greater than 0.975 (?eff.arm.simple) # * futility stop per arm when the prob of the corresponding parameter  #     being greater than 0 is smaller than 0.05 (?fut.arm.simple)  # * trial stop once all arms have stopped (?eff.trial.all and ?fut.trial.all) #     or the max sample size was reached   sim = batss.glm(model            = y ~ group,                    var              = list(y     = rnorm,                                         group = alloc.balanced),                 var.control      = list(y = list(sd = 5)),                 beta             = c(1, 1, 2),                 which            = c(2:3),                 alternative      = \"greater\",                 R                = 20,                 N                = 200,                 interim          = list(recruited = seq(100, 180, 20)),                 prob0            = c(C = 1/3, T1 = 1/3, T2 = 1/3),                 eff.arm          = eff.arm.simple,                 eff.arm.control  = list(b = 0.975),                 fut.arm          = fut.arm.simple,                 fut.arm.control  = list(b = 0.05),                 computation      = \"parallel\",                 H0               = TRUE,                 mc.cores         = 2)# better: parallel::detectCores()-1 #>     Initialisation #>     Evaluation of H1 #>     Evaluation of H0 #>     Results # }"},{"path":"/reference/eff.arm.infofract.html","id":null,"dir":"Reference","previous_headings":"","what":"information-fraction based arm efficacy stop — eff.arm.infofract","title":"information-fraction based arm efficacy stop — eff.arm.infofract","text":"allows stopping arm efficacy given look probability corresponding target parameter greater smaller (depending argument 'alternative' batss.glm) delta.eff greater function information fraction look.","code":""},{"path":"/reference/eff.arm.infofract.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"information-fraction based arm efficacy stop — eff.arm.infofract","text":"","code":"eff.arm.infofract(posterior, b, n, N, p)"},{"path":"/reference/eff.arm.infofract.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"information-fraction based arm efficacy stop — eff.arm.infofract","text":"posterior 'BATSS' ingredient 'posterior' corresponding, context, (posterior) probability target parameter greater smaller (depending argument 'alternative' batss.glm) 'delta.eff'. b tuning parameter (defined eff.arm.control). n 'BATSS' ingredient 'n' corresponding vector number recruited participants per arm including control group. N 'BATSS' ingredient '`N' corresponding maximum (planned) sample size. p tuning parameter (defined eff.arm.control).","code":""},{"path":"/reference/eff.arm.infofract.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"information-fraction based arm efficacy stop — eff.arm.infofract","text":"eff.arm.infofract returns logical constant.","code":""},{"path":"/reference/eff.arm.simple.html","id":null,"dir":"Reference","previous_headings":"","what":"Simple arm efficacy stop — eff.arm.simple","title":"Simple arm efficacy stop — eff.arm.simple","text":"allows stopping arm efficacy given look probability corresponding target parameter greater smaller (depending argument 'alternative' batss.glm) delta.eff greater fixed value b.","code":""},{"path":"/reference/eff.arm.simple.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simple arm efficacy stop — eff.arm.simple","text":"","code":"eff.arm.simple(posterior, b)"},{"path":"/reference/eff.arm.simple.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simple arm efficacy stop — eff.arm.simple","text":"posterior 'BATSS' ingredient 'posterior' corresponding, context, (posterior) probability target parameter greater smaller (depending argument 'alternative' batss.glm) 'delta.eff'. b cut-value used declare efficacy (defined eff.arm.control).","code":""},{"path":"/reference/eff.arm.simple.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simple arm efficacy stop — eff.arm.simple","text":"eff.arm.simple returns logical constant.","code":""},{"path":"/reference/eff.trial.all.html","id":null,"dir":"Reference","previous_headings":"","what":"trial efficacy stop — eff.trial.all","title":"trial efficacy stop — eff.trial.all","text":"allows stopping trial efficacy target parameters reached efficacy look interest .","code":""},{"path":"/reference/eff.trial.all.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"trial efficacy stop — eff.trial.all","text":"","code":"eff.trial.all(eff.target)"},{"path":"/reference/eff.trial.all.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"trial efficacy stop — eff.trial.all","text":"eff.target 'BATSS' ingredient 'eff.target' corresponding logical vector length argument (.e., number target parameters) indicating efficacy reached target parameter stage previous stage.","code":""},{"path":"/reference/eff.trial.all.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"trial efficacy stop — eff.trial.all","text":"eff.trial.returns logical constant.","code":""},{"path":"/reference/eff.trial.any.html","id":null,"dir":"Reference","previous_headings":"","what":"trial efficacy stop — eff.trial.any","title":"trial efficacy stop — eff.trial.any","text":"allows stopping trial efficacy least one target parameter reached efficacy look interest.","code":""},{"path":"/reference/eff.trial.any.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"trial efficacy stop — eff.trial.any","text":"","code":"eff.trial.any(eff.target)"},{"path":"/reference/eff.trial.any.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"trial efficacy stop — eff.trial.any","text":"eff.target 'BATSS' ingredient 'eff.target' corresponding logical vector length argument (.e., number target parameters) indicating efficacy reached target parameter stage previous stage.","code":""},{"path":"/reference/eff.trial.any.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"trial efficacy stop — eff.trial.any","text":"eff.trial.returns logical constant.","code":""},{"path":"/reference/fut.arm.simple.html","id":null,"dir":"Reference","previous_headings":"","what":"arm futility stop — fut.arm.simple","title":"arm futility stop — fut.arm.simple","text":"allows stopping arm futility probability corresponding target parameter greater smaller (depending argument 'alternative' batss.glm) 'delta.fut' smaller fixed value 'b'","code":""},{"path":"/reference/fut.arm.simple.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"arm futility stop — fut.arm.simple","text":"","code":"fut.arm.simple(posterior, b)"},{"path":"/reference/fut.arm.simple.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"arm futility stop — fut.arm.simple","text":"posterior 'BATSS' ingredient 'posterior' corresponding, context, (posterior) probability target parameter greater smaller (depending argument 'alternative' batss.glm) 'delta.fut'. b cut-value used declare futility (defined fut.arm.control).","code":""},{"path":"/reference/fut.arm.simple.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"arm futility stop — fut.arm.simple","text":"fut.arm.simple returns logical constant.","code":""},{"path":"/reference/fut.trial.all.html","id":null,"dir":"Reference","previous_headings":"","what":"trial futility stop — fut.trial.all","title":"trial futility stop — fut.trial.all","text":"allows stopping trial efficacy active treatment reached futility look interest .","code":""},{"path":"/reference/fut.trial.all.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"trial futility stop — fut.trial.all","text":"","code":"fut.trial.all(fut.target)"},{"path":"/reference/fut.trial.all.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"trial futility stop — fut.trial.all","text":"fut.target 'BATSS' ingredient 'fut.target' corresponding logical vector length argument (.e., number target parameters) indicating futility declared target parameter stage previous stage.","code":""},{"path":"/reference/fut.trial.all.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"trial futility stop — fut.trial.all","text":"fut.trial.returns logical constant.","code":""},{"path":"/reference/plot.batss.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot function for 'BATSS' outputs — plot.batss","title":"Plot function for 'BATSS' outputs — plot.batss","text":"Plot objects class 'batss'","code":""},{"path":"/reference/plot.batss.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot function for 'BATSS' outputs — plot.batss","text":"","code":"# S3 method for batss plot(   x,   type = \"size\",   hypothesis = \"H1\",   title = TRUE,   legend = TRUE,   col = c(\"#008B0040\", \"#8B3A3A40\", \"#8B897040\", \"#FF990075\", \"blue\"),   ... )"},{"path":"/reference/plot.batss.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot function for 'BATSS' outputs — plot.batss","text":"x object class 'batss' (.e., output function batss.glm). type character string indicating type plot options 'size' (default) display total per group sample size observed Monte Carlo trials, 'estimates' display Monte Carlo trial target estimates function sample size. hypothesis character string indicating alternative hypothesis use analyses considering \"H0\" \"H1\", options \"H1\" (default) \"H0\". title Either logical indicating title added string (class character) indicating title added. title equals TRUE (default), title ''H1' ''H0' (depending argument hypothesis) added outer margin plot. outer margin space added title = FALSE. legend logical (default set TRUE) indicating , 'type = estimates', legend added bottom plot. col vector length 5 specifiying colour respectively assigned / efficacy, ii/ futility, iii/ neither iv/ color-coding trials type = \"estimates\". 5th colour used lines. Default c(\"#8B897040\",\"#008B0040\",\"#8B3A3A40\",\"#FF990075\",\"blue\") 2 last digits long hexadecimal strings colours 1 4 specify level transluency. Refer Section 'colour specification' par details. length col equals 1, colour used cases. type = \"size\", 3rd 5th colours vector col used display boxplots lines. ... Additional arguments affecting plot produced, like ylim ylab.","code":""},{"path":"/reference/plot.batss.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot function for 'BATSS' outputs — plot.batss","text":"Generates graphical displays results objects class 'batss'.","code":""},{"path":[]},{"path":"/reference/print.batss.html","id":null,"dir":"Reference","previous_headings":"","what":"Print function for BATSS outputs — print.batss","title":"Print function for BATSS outputs — print.batss","text":"Print method function objects class 'batss' (.e., output function batss.glm).","code":""},{"path":"/reference/print.batss.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print function for BATSS outputs — print.batss","text":"","code":"# S3 method for batss print(x, ...)"},{"path":"/reference/print.batss.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print function for BATSS outputs — print.batss","text":"x object class 'batss'. ... Additional arguments affecting print produced.","code":""},{"path":"/reference/print.batss.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print function for BATSS outputs — print.batss","text":"Prints information objects class 'batss'.","code":""},{"path":[]},{"path":"/reference/summary.batss.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary function for 'BATSS' outputs — summary.batss","title":"Summary function for 'BATSS' outputs — summary.batss","text":"Summary method function objects class 'batss'.","code":""},{"path":"/reference/summary.batss.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary function for 'BATSS' outputs — summary.batss","text":"","code":"# S3 method for batss summary(object, full = FALSE, ...)"},{"path":"/reference/summary.batss.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary function for 'BATSS' outputs — summary.batss","text":"object object class 'batss' (.e., output function batss.glm). full logical indicating standard (full = FALSE, default) extended output (full = TRUE) returned. ... Additional arguments affecting summary produced.","code":""},{"path":"/reference/summary.batss.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary function for 'BATSS' outputs — summary.batss","text":"Prints summary objects class 'batss'.","code":""},{"path":[]},{"path":"/news/index.html","id":"version-0712","dir":"Changelog","previous_headings":"","what":"Version 0.7.12","title":"Version 0.7.12","text":"Initial release BATSS pkgdown","code":""},{"path":"/news/index.html","id":"version-0713","dir":"Changelog","previous_headings":"","what":"Version 0.7.13","title":"Version 0.7.13","text":"Minor improvements function plot.batss Minor changes vignette dedicated binomial endpoint","code":""},{"path":"/news/index.html","id":"version-0714","dir":"Changelog","previous_headings":"","what":"Version 0.7.14","title":"Version 0.7.14","text":"CRAN release: 2024-07-14 Improvements functions plot.batss summary.batss related cases efficacy futility criteria simulatneously met arm Minor improvements (help pages, printed messages)","code":""},{"path":"/news/index.html","id":"version-0715","dir":"Changelog","previous_headings":"","what":"Version 0.7.15","title":"Version 0.7.15","text":"Resolution bug affecting designs single target parameter","code":""},{"path":"/news/index.html","id":"version-100","dir":"Changelog","previous_headings":"","what":"Version 1.0.0","title":"Version 1.0.0","text":"Checks Minor improvments internal/generic functions","code":""}]
